<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>x2d: /Users/godexsoft/Development/Nako/x2d/x2d/x2d/src/util/picopng.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>/Users/godexsoft/Development/Nako/x2d/x2d/x2d/src/util/picopng.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#pragma once</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#ifndef __X2D_PICOPNG_H__</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define __X2D_PICOPNG_H__</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="keyword">namespace </span>x2d {
<a name="l00008"></a>00008 <span class="keyword">namespace </span>png {
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keywordtype">int</span> decodePNG(std::vector&lt;unsigned char&gt;&amp; out_image_32bit, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; image_width, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; image_height, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in_png, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> in_size)
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012   <span class="comment">// picoPNG version 20080503</span>
<a name="l00013"></a>00013   <span class="comment">// Copyright (c) 2005-2008 Lode Vandevenne</span>
<a name="l00014"></a>00014   <span class="comment">//</span>
<a name="l00015"></a>00015   <span class="comment">// This software is provided &#39;as-is&#39;, without any express or implied</span>
<a name="l00016"></a>00016   <span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
<a name="l00017"></a>00017   <span class="comment">// arising from the use of this software.</span>
<a name="l00018"></a>00018   <span class="comment">//</span>
<a name="l00019"></a>00019   <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00020"></a>00020   <span class="comment">// including commercial applications, and to alter it and redistribute it</span>
<a name="l00021"></a>00021   <span class="comment">// freely, subject to the following restrictions:</span>
<a name="l00022"></a>00022   <span class="comment">//</span>
<a name="l00023"></a>00023   <span class="comment">//     1. The origin of this software must not be misrepresented; you must not</span>
<a name="l00024"></a>00024   <span class="comment">//     claim that you wrote the original software. If you use this software</span>
<a name="l00025"></a>00025   <span class="comment">//     in a product, an acknowledgment in the product documentation would be</span>
<a name="l00026"></a>00026   <span class="comment">//     appreciated but is not required.</span>
<a name="l00027"></a>00027   <span class="comment">//     2. Altered source versions must be plainly marked as such, and must not be</span>
<a name="l00028"></a>00028   <span class="comment">//     misrepresented as being the original software.</span>
<a name="l00029"></a>00029   <span class="comment">//     3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00030"></a>00030         
<a name="l00031"></a>00031   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LENBASE[29] =  {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
<a name="l00032"></a>00032   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LENEXTRA[29] = {0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0};
<a name="l00033"></a>00033   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> DISTBASE[30] =  {1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};
<a name="l00034"></a>00034   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> DISTEXTRA[30] = {0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13};
<a name="l00035"></a>00035   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> CLCL[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}; <span class="comment">//code length code lengths</span>
<a name="l00036"></a>00036   <span class="keyword">struct </span>Zlib <span class="comment">//nested functions for zlib decompression</span>
<a name="l00037"></a>00037   {
<a name="l00038"></a>00038     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitFromStream(<span class="keywordtype">size_t</span>&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits) { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = (bits[bitp &gt;&gt; 3] &gt;&gt; (bitp &amp; 0x7)) &amp; 1; bitp++; <span class="keywordflow">return</span> result;}
<a name="l00039"></a>00039     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitsFromStream(<span class="keywordtype">size_t</span>&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, <span class="keywordtype">size_t</span> nbits)
<a name="l00040"></a>00040     {
<a name="l00041"></a>00041       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = 0;
<a name="l00042"></a>00042       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; nbits; i++) result += (readBitFromStream(bitp, bits)) &lt;&lt; i;
<a name="l00043"></a>00043       <span class="keywordflow">return</span> result;
<a name="l00044"></a>00044     }
<a name="l00045"></a>00045     <span class="keyword">struct </span>HuffmanTree
<a name="l00046"></a>00046     {
<a name="l00047"></a>00047       <span class="keywordtype">int</span> makeFromLengths(<span class="keyword">const</span> std::vector&lt;unsigned long&gt;&amp; bitlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxbitlen)
<a name="l00048"></a>00048       { <span class="comment">//make tree given the lengths</span>
<a name="l00049"></a>00049         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numcodes = (<span class="keywordtype">unsigned</span> long)(bitlen.size()), treepos = 0, nodefilled = 0;
<a name="l00050"></a>00050         std::vector&lt;unsigned long&gt; tree1d(numcodes), blcount(maxbitlen + 1, 0), nextcode(maxbitlen + 1, 0);
<a name="l00051"></a>00051         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bits = 0; bits &lt; numcodes; bits++) blcount[bitlen[bits]]++; <span class="comment">//count number of instances of each code length</span>
<a name="l00052"></a>00052         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bits = 1; bits &lt;= maxbitlen; bits++) nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) &lt;&lt; 1;
<a name="l00053"></a>00053         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; numcodes; n++) <span class="keywordflow">if</span>(bitlen[n] != 0) tree1d[n] = nextcode[bitlen[n]]++; <span class="comment">//generate all the codes</span>
<a name="l00054"></a>00054         tree2d.clear(); tree2d.resize(numcodes * 2, 32767); <span class="comment">//32767 here means the tree2d isn&#39;t filled there yet</span>
<a name="l00055"></a>00055         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; numcodes; n++) <span class="comment">//the codes</span>
<a name="l00056"></a>00056         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i = 0; i &lt; bitlen[n]; i++) <span class="comment">//the bits for this code</span>
<a name="l00057"></a>00057         {
<a name="l00058"></a>00058           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit = (tree1d[n] &gt;&gt; (bitlen[n] - i - 1)) &amp; 1;
<a name="l00059"></a>00059           <span class="keywordflow">if</span>(treepos &gt; numcodes - 2) <span class="keywordflow">return</span> 55;
<a name="l00060"></a>00060           <span class="keywordflow">if</span>(tree2d[2 * treepos + bit] == 32767) <span class="comment">//not yet filled in</span>
<a name="l00061"></a>00061           {
<a name="l00062"></a>00062             <span class="keywordflow">if</span>(i + 1 == bitlen[n]) { tree2d[2 * treepos + bit] = n; treepos = 0; } <span class="comment">//last bit</span>
<a name="l00063"></a>00063             <span class="keywordflow">else</span> { tree2d[2 * treepos + bit] = ++nodefilled + numcodes; treepos = nodefilled; } <span class="comment">//addresses are encoded as values &gt; numcodes</span>
<a name="l00064"></a>00064           }
<a name="l00065"></a>00065           <span class="keywordflow">else</span> treepos = tree2d[2 * treepos + bit] - numcodes; <span class="comment">//subtract numcodes from address to get address value</span>
<a name="l00066"></a>00066         }
<a name="l00067"></a>00067         <span class="keywordflow">return</span> 0;
<a name="l00068"></a>00068       }
<a name="l00069"></a>00069       <span class="keywordtype">int</span> decode(<span class="keywordtype">bool</span>&amp; decoded, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&amp; result, <span class="keywordtype">size_t</span>&amp; treepos, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit)<span class="keyword"> const</span>
<a name="l00070"></a>00070 <span class="keyword">      </span>{ <span class="comment">//Decodes a symbol from the tree</span>
<a name="l00071"></a>00071         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numcodes = (<span class="keywordtype">unsigned</span> long)tree2d.size() / 2;
<a name="l00072"></a>00072         <span class="keywordflow">if</span>(treepos &gt;= numcodes) <span class="keywordflow">return</span> 11; <span class="comment">//error: you appeared outside the codetree</span>
<a name="l00073"></a>00073         result = tree2d[2 * treepos + bit];
<a name="l00074"></a>00074         decoded = (result &lt; numcodes);
<a name="l00075"></a>00075         treepos = decoded ? 0 : result - numcodes;
<a name="l00076"></a>00076         <span class="keywordflow">return</span> 0;
<a name="l00077"></a>00077       }
<a name="l00078"></a>00078       std::vector&lt;unsigned long&gt; tree2d; <span class="comment">//2D representation of a huffman tree: The one dimension is &quot;0&quot; or &quot;1&quot;, the other contains all nodes and leaves of the tree.</span>
<a name="l00079"></a>00079     };
<a name="l00080"></a>00080     <span class="keyword">struct </span>Inflator
<a name="l00081"></a>00081     {
<a name="l00082"></a>00082       <span class="keywordtype">int</span> error;
<a name="l00083"></a>00083       <span class="keywordtype">void</span> inflate(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keywordtype">size_t</span> inpos = 0)
<a name="l00084"></a>00084       {
<a name="l00085"></a>00085         <span class="keywordtype">size_t</span> bp = 0, pos = 0; <span class="comment">//bit pointer and byte pointer</span>
<a name="l00086"></a>00086         error = 0;
<a name="l00087"></a>00087         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> BFINAL = 0;
<a name="l00088"></a>00088         <span class="keywordflow">while</span>(!BFINAL &amp;&amp; !error)
<a name="l00089"></a>00089         {
<a name="l00090"></a>00090           <span class="keywordflow">if</span>(bp &gt;&gt; 3 &gt;= in.size()) { error = 52; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span>
<a name="l00091"></a>00091           BFINAL = readBitFromStream(bp, &amp;in[inpos]);
<a name="l00092"></a>00092           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> BTYPE = readBitFromStream(bp, &amp;in[inpos]); BTYPE += 2 * readBitFromStream(bp, &amp;in[inpos]);
<a name="l00093"></a>00093           <span class="keywordflow">if</span>(BTYPE == 3) { error = 20; <span class="keywordflow">return</span>; } <span class="comment">//error: invalid BTYPE</span>
<a name="l00094"></a>00094           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(BTYPE == 0) inflateNoCompression(out, &amp;in[inpos], bp, pos, in.size());
<a name="l00095"></a>00095           <span class="keywordflow">else</span> inflateHuffmanBlock(out, &amp;in[inpos], bp, pos, in.size(), BTYPE);
<a name="l00096"></a>00096         }
<a name="l00097"></a>00097         <span class="keywordflow">if</span>(!error) out.resize(pos); <span class="comment">//Only now we know the true size of out, resize it to that</span>
<a name="l00098"></a>00098       }
<a name="l00099"></a>00099       <span class="keywordtype">void</span> generateFixedTrees(HuffmanTree&amp; tree, HuffmanTree&amp; treeD) <span class="comment">//get the tree of a deflated block with fixed tree</span>
<a name="l00100"></a>00100       {
<a name="l00101"></a>00101         std::vector&lt;unsigned long&gt; bitlen(288, 8), bitlenD(32, 5);;
<a name="l00102"></a>00102         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 144; i &lt;= 255; i++) bitlen[i] = 9;
<a name="l00103"></a>00103         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 256; i &lt;= 279; i++) bitlen[i] = 7;
<a name="l00104"></a>00104         tree.makeFromLengths(bitlen, 15);
<a name="l00105"></a>00105         treeD.makeFromLengths(bitlenD, 15);
<a name="l00106"></a>00106       }
<a name="l00107"></a>00107       HuffmanTree codetree, codetreeD, codelengthcodetree; <span class="comment">//the code tree for Huffman codes, dist codes, and code length codes</span>
<a name="l00108"></a>00108       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> huffmanDecodeSymbol(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span>&amp; bp, <span class="keyword">const</span> HuffmanTree&amp; codetree, <span class="keywordtype">size_t</span> inlength)
<a name="l00109"></a>00109       { <span class="comment">//decode a single symbol from given list of bits with given code tree. return value is the symbol</span>
<a name="l00110"></a>00110         <span class="keywordtype">bool</span> decoded; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ct;
<a name="l00111"></a>00111         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> treepos = 0;;)
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113           <span class="keywordflow">if</span>((bp &amp; 0x07) == 0 &amp;&amp; (bp &gt;&gt; 3) &gt; inlength) { error = 10; <span class="keywordflow">return</span> 0; } <span class="comment">//error: end reached without endcode</span>
<a name="l00114"></a>00114           error = codetree.decode(decoded, ct, treepos, readBitFromStream(bp, in)); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span> 0; <span class="comment">//stop, an error happened</span>
<a name="l00115"></a>00115           <span class="keywordflow">if</span>(decoded) <span class="keywordflow">return</span> ct;
<a name="l00116"></a>00116         }
<a name="l00117"></a>00117       }
<a name="l00118"></a>00118       <span class="keywordtype">void</span> getTreeInflateDynamic(HuffmanTree&amp; tree, HuffmanTree&amp; treeD, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span>&amp; bp, <span class="keywordtype">size_t</span> inlength)
<a name="l00119"></a>00119       { <span class="comment">//get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree</span>
<a name="l00120"></a>00120         std::vector&lt;unsigned long&gt; bitlen(288, 0), bitlenD(32, 0);
<a name="l00121"></a>00121         <span class="keywordflow">if</span>(bp &gt;&gt; 3 &gt;= inlength - 2) { error = 49; <span class="keywordflow">return</span>; } <span class="comment">//the bit pointer is or will go past the memory</span>
<a name="l00122"></a>00122         <span class="keywordtype">size_t</span> HLIT =  readBitsFromStream(bp, in, 5) + 257; <span class="comment">//number of literal/length codes + 257</span>
<a name="l00123"></a>00123         <span class="keywordtype">size_t</span> HDIST = readBitsFromStream(bp, in, 5) + 1; <span class="comment">//number of dist codes + 1</span>
<a name="l00124"></a>00124         <span class="keywordtype">size_t</span> HCLEN = readBitsFromStream(bp, in, 4) + 4; <span class="comment">//number of code length codes + 4</span>
<a name="l00125"></a>00125         std::vector&lt;unsigned long&gt; codelengthcode(19); <span class="comment">//lengths of tree to decode the lengths of the dynamic tree</span>
<a name="l00126"></a>00126         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; 19; i++) codelengthcode[CLCL[i]] = (i &lt; HCLEN) ? readBitsFromStream(bp, in, 3) : 0;
<a name="l00127"></a>00127         error = codelengthcodetree.makeFromLengths(codelengthcode, 7); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00128"></a>00128         <span class="keywordtype">size_t</span> i = 0, replength;
<a name="l00129"></a>00129         <span class="keywordflow">while</span>(i &lt; HLIT + HDIST)
<a name="l00130"></a>00130         {
<a name="l00131"></a>00131           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = huffmanDecodeSymbol(in, bp, codelengthcodetree, inlength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00132"></a>00132           <span class="keywordflow">if</span>(code &lt;= 15)  { <span class="keywordflow">if</span>(i &lt; HLIT) bitlen[i++] = code; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = code; } <span class="comment">//a length code</span>
<a name="l00133"></a>00133           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(code == 16) <span class="comment">//repeat previous</span>
<a name="l00134"></a>00134           {
<a name="l00135"></a>00135             <span class="keywordflow">if</span>(bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span>
<a name="l00136"></a>00136             replength = 3 + readBitsFromStream(bp, in, 2);
<a name="l00137"></a>00137             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value; <span class="comment">//set value to the previous code</span>
<a name="l00138"></a>00138             <span class="keywordflow">if</span>((i - 1) &lt; HLIT) value = bitlen[i - 1];
<a name="l00139"></a>00139             <span class="keywordflow">else</span> value = bitlenD[i - HLIT - 1];
<a name="l00140"></a>00140             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span>
<a name="l00141"></a>00141             {
<a name="l00142"></a>00142               <span class="keywordflow">if</span>(i &gt;= HLIT + HDIST) { error = 13; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span>
<a name="l00143"></a>00143               <span class="keywordflow">if</span>(i &lt; HLIT) bitlen[i++] = value; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = value;
<a name="l00144"></a>00144             }
<a name="l00145"></a>00145           }
<a name="l00146"></a>00146           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(code == 17) <span class="comment">//repeat &quot;0&quot; 3-10 times</span>
<a name="l00147"></a>00147           {
<a name="l00148"></a>00148             <span class="keywordflow">if</span>(bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span>
<a name="l00149"></a>00149             replength = 3 + readBitsFromStream(bp, in, 3);
<a name="l00150"></a>00150             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span>
<a name="l00151"></a>00151             {
<a name="l00152"></a>00152               <span class="keywordflow">if</span>(i &gt;= HLIT + HDIST) { error = 14; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span>
<a name="l00153"></a>00153               <span class="keywordflow">if</span>(i &lt; HLIT) bitlen[i++] = 0; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = 0;
<a name="l00154"></a>00154             }
<a name="l00155"></a>00155           }
<a name="l00156"></a>00156           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(code == 18) <span class="comment">//repeat &quot;0&quot; 11-138 times</span>
<a name="l00157"></a>00157           {
<a name="l00158"></a>00158             <span class="keywordflow">if</span>(bp &gt;&gt; 3 &gt;= inlength) { error = 50; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer jumps past memory</span>
<a name="l00159"></a>00159             replength = 11 + readBitsFromStream(bp, in, 7);
<a name="l00160"></a>00160             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n = 0; n &lt; replength; n++) <span class="comment">//repeat this value in the next lengths</span>
<a name="l00161"></a>00161             {
<a name="l00162"></a>00162               <span class="keywordflow">if</span>(i &gt;= HLIT + HDIST) { error = 15; <span class="keywordflow">return</span>; } <span class="comment">//error: i is larger than the amount of codes</span>
<a name="l00163"></a>00163               <span class="keywordflow">if</span>(i &lt; HLIT) bitlen[i++] = 0; <span class="keywordflow">else</span> bitlenD[i++ - HLIT] = 0;
<a name="l00164"></a>00164             }
<a name="l00165"></a>00165           }
<a name="l00166"></a>00166           <span class="keywordflow">else</span> { error = 16; <span class="keywordflow">return</span>; } <span class="comment">//error: somehow an unexisting code appeared. This can never happen.</span>
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168         <span class="keywordflow">if</span>(bitlen[256] == 0) { error = 64; <span class="keywordflow">return</span>; } <span class="comment">//the length of the end code 256 must be larger than 0</span>
<a name="l00169"></a>00169         error = tree.makeFromLengths(bitlen, 15); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>; <span class="comment">//now we&#39;ve finally got HLIT and HDIST, so generate the code trees, and the function is done</span>
<a name="l00170"></a>00170         error = treeD.makeFromLengths(bitlenD, 15); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00171"></a>00171       }
<a name="l00172"></a>00172       <span class="keywordtype">void</span> inflateHuffmanBlock(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span>&amp; bp, <span class="keywordtype">size_t</span>&amp; pos, <span class="keywordtype">size_t</span> inlength, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> btype) 
<a name="l00173"></a>00173       {
<a name="l00174"></a>00174         <span class="keywordflow">if</span>(btype == 1) { generateFixedTrees(codetree, codetreeD); }
<a name="l00175"></a>00175         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(btype == 2) { getTreeInflateDynamic(codetree, codetreeD, in, bp, inlength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>; }
<a name="l00176"></a>00176         <span class="keywordflow">for</span>(;;)
<a name="l00177"></a>00177         {
<a name="l00178"></a>00178           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = huffmanDecodeSymbol(in, bp, codetree, inlength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00179"></a>00179           <span class="keywordflow">if</span>(code == 256) <span class="keywordflow">return</span>; <span class="comment">//end code</span>
<a name="l00180"></a>00180           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(code &lt;= 255) <span class="comment">//literal symbol</span>
<a name="l00181"></a>00181           {
<a name="l00182"></a>00182             <span class="keywordflow">if</span>(pos &gt;= out.size()) out.resize((pos + 1) * 2); <span class="comment">//reserve more room</span>
<a name="l00183"></a>00183             out[pos++] = (<span class="keywordtype">unsigned</span> char)(code);
<a name="l00184"></a>00184           }
<a name="l00185"></a>00185           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(code &gt;= 257 &amp;&amp; code &lt;= 285) <span class="comment">//length code</span>
<a name="l00186"></a>00186           {
<a name="l00187"></a>00187             <span class="keywordtype">size_t</span> length = LENBASE[code - 257], numextrabits = LENEXTRA[code - 257];
<a name="l00188"></a>00188             <span class="keywordflow">if</span>((bp &gt;&gt; 3) &gt;= inlength) { error = 51; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span>
<a name="l00189"></a>00189             length += readBitsFromStream(bp, in, numextrabits);
<a name="l00190"></a>00190             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> codeD = huffmanDecodeSymbol(in, bp, codetreeD, inlength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00191"></a>00191             <span class="keywordflow">if</span>(codeD &gt; 29) { error = 18; <span class="keywordflow">return</span>; } <span class="comment">//error: invalid dist code (30-31 are never used)</span>
<a name="l00192"></a>00192             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dist = DISTBASE[codeD], numextrabitsD = DISTEXTRA[codeD];
<a name="l00193"></a>00193             <span class="keywordflow">if</span>((bp &gt;&gt; 3) &gt;= inlength) { error = 51; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span>
<a name="l00194"></a>00194             dist += readBitsFromStream(bp, in, numextrabitsD);
<a name="l00195"></a>00195             <span class="keywordtype">size_t</span> start = pos, back = start - dist; <span class="comment">//backwards</span>
<a name="l00196"></a>00196             <span class="keywordflow">if</span>(pos + length &gt;= out.size()) out.resize((pos + length) * 2); <span class="comment">//reserve more room</span>
<a name="l00197"></a>00197             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; length; i++) { out[pos++] = out[back++]; <span class="keywordflow">if</span>(back &gt;= start) back = start - dist; }
<a name="l00198"></a>00198           }
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200       }
<a name="l00201"></a>00201       <span class="keywordtype">void</span> inflateNoCompression(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span>&amp; bp, <span class="keywordtype">size_t</span>&amp; pos, <span class="keywordtype">size_t</span> inlength)
<a name="l00202"></a>00202       {
<a name="l00203"></a>00203         <span class="keywordflow">while</span>((bp &amp; 0x7) != 0) bp++; <span class="comment">//go to first boundary of byte</span>
<a name="l00204"></a>00204         <span class="keywordtype">size_t</span> p = bp / 8;
<a name="l00205"></a>00205         <span class="keywordflow">if</span>(p &gt;= inlength - 4) { error = 52; <span class="keywordflow">return</span>; } <span class="comment">//error, bit pointer will jump past memory</span>
<a name="l00206"></a>00206         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LEN = in[p] + 256 * in[p + 1], NLEN = in[p + 2] + 256 * in[p + 3]; p += 4;
<a name="l00207"></a>00207         <span class="keywordflow">if</span>(LEN + NLEN != 65535) { error = 21; <span class="keywordflow">return</span>; } <span class="comment">//error: NLEN is not one&#39;s complement of LEN</span>
<a name="l00208"></a>00208         <span class="keywordflow">if</span>(pos + LEN &gt;= out.size()) out.resize(pos + LEN);
<a name="l00209"></a>00209         <span class="keywordflow">if</span>(p + LEN &gt; inlength) { error = 23; <span class="keywordflow">return</span>; } <span class="comment">//error: reading outside of in buffer</span>
<a name="l00210"></a>00210         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> n = 0; n &lt; LEN; n++) out[pos++] = in[p++]; <span class="comment">//read LEN bytes of literal data</span>
<a name="l00211"></a>00211         bp = p * 8;
<a name="l00212"></a>00212       }
<a name="l00213"></a>00213     };
<a name="l00214"></a>00214     <span class="keywordtype">int</span> decompress(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in) <span class="comment">//returns error value</span>
<a name="l00215"></a>00215     {
<a name="l00216"></a>00216       Inflator inflator;
<a name="l00217"></a>00217       <span class="keywordflow">if</span>(in.size() &lt; 2) { <span class="keywordflow">return</span> 53; } <span class="comment">//error, size of zlib data too small</span>
<a name="l00218"></a>00218       <span class="keywordflow">if</span>((in[0] * 256 + in[1]) % 31 != 0) { <span class="keywordflow">return</span> 24; } <span class="comment">//error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way</span>
<a name="l00219"></a>00219       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> CM = in[0] &amp; 15, CINFO = (in[0] &gt;&gt; 4) &amp; 15, FDICT = (in[1] &gt;&gt; 5) &amp; 1;
<a name="l00220"></a>00220       <span class="keywordflow">if</span>(CM != 8 || CINFO &gt; 7) { <span class="keywordflow">return</span> 25; } <span class="comment">//error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec</span>
<a name="l00221"></a>00221       <span class="keywordflow">if</span>(FDICT != 0) { <span class="keywordflow">return</span> 26; } <span class="comment">//error: the specification of PNG says about the zlib stream: &quot;The additional flags shall not specify a preset dictionary.&quot;</span>
<a name="l00222"></a>00222       inflator.inflate(out, in, 2);
<a name="l00223"></a>00223       <span class="keywordflow">return</span> inflator.error; <span class="comment">//note: adler32 checksum was skipped and ignored</span>
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225   };
<a name="l00226"></a>00226   <span class="keyword">struct </span>PNG <span class="comment">//nested functions for PNG decoding</span>
<a name="l00227"></a>00227   {
<a name="l00228"></a>00228     <span class="keyword">struct </span>Info
<a name="l00229"></a>00229     {
<a name="l00230"></a>00230       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> width, height, colorType, bitDepth, compressionMethod, filterMethod, interlaceMethod, key_r, key_g, key_b;
<a name="l00231"></a>00231       <span class="keywordtype">bool</span> key_defined; <span class="comment">//is a transparent color key given?</span>
<a name="l00232"></a>00232       std::vector&lt;unsigned char&gt; palette;
<a name="l00233"></a>00233     } info;
<a name="l00234"></a>00234     <span class="keywordtype">int</span> error;
<a name="l00235"></a>00235     <span class="keywordtype">void</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size)
<a name="l00236"></a>00236     {
<a name="l00237"></a>00237       error = 0;
<a name="l00238"></a>00238       <span class="keywordflow">if</span>(size == 0 || in == 0) { error = 48; <span class="keywordflow">return</span>; } <span class="comment">//the given data is empty</span>
<a name="l00239"></a>00239       readPngHeader(&amp;in[0], size); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00240"></a>00240       <span class="keywordtype">size_t</span> pos = 33; <span class="comment">//first byte of the first chunk after the header</span>
<a name="l00241"></a>00241       std::vector&lt;unsigned char&gt; idat; <span class="comment">//the data from idat chunks</span>
<a name="l00242"></a>00242       <span class="keywordtype">bool</span> IEND = <span class="keyword">false</span>, known_type = <span class="keyword">true</span>;
<a name="l00243"></a>00243       info.key_defined = <span class="keyword">false</span>;
<a name="l00244"></a>00244       <span class="keywordflow">while</span>(!IEND) <span class="comment">//loop through the chunks, ignoring unknown chunks and stopping at IEND chunk. IDAT data is put at the start of the in buffer</span>
<a name="l00245"></a>00245       {
<a name="l00246"></a>00246         <span class="keywordflow">if</span>(pos + 8 &gt;= size) { error = 30; <span class="keywordflow">return</span>; } <span class="comment">//error: size of the in buffer too small to contain next chunk</span>
<a name="l00247"></a>00247         <span class="keywordtype">size_t</span> chunkLength = read32bitInt(&amp;in[pos]); pos += 4;
<a name="l00248"></a>00248         <span class="keywordflow">if</span>(chunkLength &gt; 2147483647) { error = 63; <span class="keywordflow">return</span>; }
<a name="l00249"></a>00249         <span class="keywordflow">if</span>(pos + chunkLength &gt;= size) { error = 35; <span class="keywordflow">return</span>; } <span class="comment">//error: size of the in buffer too small to contain next chunk</span>
<a name="l00250"></a>00250         <span class="keywordflow">if</span>(in[pos + 0] == <span class="charliteral">&#39;I&#39;</span> &amp;&amp; in[pos + 1] == <span class="charliteral">&#39;D&#39;</span> &amp;&amp; in[pos + 2] == <span class="charliteral">&#39;A&#39;</span> &amp;&amp; in[pos + 3] == <span class="charliteral">&#39;T&#39;</span>) <span class="comment">//IDAT chunk, containing compressed image data</span>
<a name="l00251"></a>00251         {
<a name="l00252"></a>00252           idat.insert(idat.end(), &amp;in[pos + 4], &amp;in[pos + 4 + chunkLength]);
<a name="l00253"></a>00253           pos += (4 + chunkLength);
<a name="l00254"></a>00254         }
<a name="l00255"></a>00255         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(in[pos + 0] == <span class="charliteral">&#39;I&#39;</span> &amp;&amp; in[pos + 1] == <span class="charliteral">&#39;E&#39;</span> &amp;&amp; in[pos + 2] == <span class="charliteral">&#39;N&#39;</span> &amp;&amp; in[pos + 3] == <span class="charliteral">&#39;D&#39;</span>)  { pos += 4; IEND = <span class="keyword">true</span>; }
<a name="l00256"></a>00256         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(in[pos + 0] == <span class="charliteral">&#39;P&#39;</span> &amp;&amp; in[pos + 1] == <span class="charliteral">&#39;L&#39;</span> &amp;&amp; in[pos + 2] == <span class="charliteral">&#39;T&#39;</span> &amp;&amp; in[pos + 3] == <span class="charliteral">&#39;E&#39;</span>) <span class="comment">//palette chunk (PLTE)</span>
<a name="l00257"></a>00257         {
<a name="l00258"></a>00258           pos += 4; <span class="comment">//go after the 4 letters</span>
<a name="l00259"></a>00259           info.palette.resize(4 * (chunkLength / 3));
<a name="l00260"></a>00260           <span class="keywordflow">if</span>(info.palette.size() &gt; (4 * 256)) { error = 38; <span class="keywordflow">return</span>; } <span class="comment">//error: palette too big</span>
<a name="l00261"></a>00261           <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; info.palette.size(); i += 4)
<a name="l00262"></a>00262           {
<a name="l00263"></a>00263             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; 3; j++) info.palette[i + j] = in[pos++]; <span class="comment">//RGB</span>
<a name="l00264"></a>00264             info.palette[i + 3] = 255; <span class="comment">//alpha</span>
<a name="l00265"></a>00265           }
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(in[pos + 0] == <span class="charliteral">&#39;t&#39;</span> &amp;&amp; in[pos + 1] == <span class="charliteral">&#39;R&#39;</span> &amp;&amp; in[pos + 2] == <span class="charliteral">&#39;N&#39;</span> &amp;&amp; in[pos + 3] == <span class="charliteral">&#39;S&#39;</span>) <span class="comment">//palette transparency chunk (tRNS)</span>
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269           pos += 4; <span class="comment">//go after the 4 letters</span>
<a name="l00270"></a>00270           <span class="keywordflow">if</span>(info.colorType == 3)
<a name="l00271"></a>00271           {
<a name="l00272"></a>00272             <span class="keywordflow">if</span>(4 * chunkLength &gt; info.palette.size()) { error = 39; <span class="keywordflow">return</span>; } <span class="comment">//error: more alpha values given than there are palette entries</span>
<a name="l00273"></a>00273             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; chunkLength; i++) info.palette[4 * i + 3] = in[pos++];
<a name="l00274"></a>00274           }
<a name="l00275"></a>00275           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(info.colorType == 0)
<a name="l00276"></a>00276           {
<a name="l00277"></a>00277             <span class="keywordflow">if</span>(chunkLength != 2) { error = 40; <span class="keywordflow">return</span>; } <span class="comment">//error: this chunk must be 2 bytes for greyscale image</span>
<a name="l00278"></a>00278             info.key_defined = 1; info.key_r = info.key_g = info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;
<a name="l00279"></a>00279           }
<a name="l00280"></a>00280           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(info.colorType == 2)
<a name="l00281"></a>00281           {
<a name="l00282"></a>00282             <span class="keywordflow">if</span>(chunkLength != 6) { error = 41; <span class="keywordflow">return</span>; } <span class="comment">//error: this chunk must be 6 bytes for RGB image</span>
<a name="l00283"></a>00283             info.key_defined = 1;
<a name="l00284"></a>00284             info.key_r = 256 * in[pos] + in[pos + 1]; pos += 2;
<a name="l00285"></a>00285             info.key_g = 256 * in[pos] + in[pos + 1]; pos += 2;
<a name="l00286"></a>00286             info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;
<a name="l00287"></a>00287           }
<a name="l00288"></a>00288           <span class="keywordflow">else</span> { error = 42; <span class="keywordflow">return</span>; } <span class="comment">//error: tRNS chunk not allowed for other color models</span>
<a name="l00289"></a>00289         }
<a name="l00290"></a>00290         <span class="keywordflow">else</span> <span class="comment">//it&#39;s not an implemented chunk type, so ignore it: skip over the data</span>
<a name="l00291"></a>00291         {
<a name="l00292"></a>00292           <span class="keywordflow">if</span>(!(in[pos + 0] &amp; 32)) { error = 69; <span class="keywordflow">return</span>; } <span class="comment">//error: unknown critical chunk (5th bit of first byte of chunk type is 0)</span>
<a name="l00293"></a>00293           pos += (chunkLength + 4); <span class="comment">//skip 4 letters and uninterpreted data of unimplemented chunk</span>
<a name="l00294"></a>00294           known_type = <span class="keyword">false</span>;
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296         pos += 4; <span class="comment">//step over CRC (which is ignored)</span>
<a name="l00297"></a>00297       }
<a name="l00298"></a>00298       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bpp = getBpp(info);
<a name="l00299"></a>00299       std::vector&lt;unsigned char&gt; scanlines(((info.width * (info.height * bpp + 7)) / 8) + info.height); <span class="comment">//now the out buffer will be filled</span>
<a name="l00300"></a>00300       Zlib zlib; <span class="comment">//decompress with the Zlib decompressor</span>
<a name="l00301"></a>00301       error = zlib.decompress(scanlines, idat); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>; <span class="comment">//stop if the zlib decompressor returned an error</span>
<a name="l00302"></a>00302       <span class="keywordtype">size_t</span> bytewidth = (bpp + 7) / 8, outlength = (info.height * info.width * bpp + 7) / 8;
<a name="l00303"></a>00303       out.resize(outlength); <span class="comment">//time to fill the out buffer</span>
<a name="l00304"></a>00304       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out_ = outlength ? &amp;out[0] : 0; <span class="comment">//use a regular pointer to the std::vector for faster code if compiled without optimization</span>
<a name="l00305"></a>00305       <span class="keywordflow">if</span>(info.interlaceMethod == 0) <span class="comment">//no interlace, just filter</span>
<a name="l00306"></a>00306       {
<a name="l00307"></a>00307         <span class="keywordtype">size_t</span> linestart = 0, linelength = (info.width * bpp + 7) / 8; <span class="comment">//length in bytes of a scanline, excluding the filtertype byte</span>
<a name="l00308"></a>00308         <span class="keywordflow">if</span>(bpp &gt;= 8) <span class="comment">//byte per byte</span>
<a name="l00309"></a>00309         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> y = 0; y &lt; info.height; y++)
<a name="l00310"></a>00310         {
<a name="l00311"></a>00311           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType = scanlines[linestart];
<a name="l00312"></a>00312           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* prevline = (y == 0) ? 0 : &amp;out_[(y - 1) * info.width * bytewidth];
<a name="l00313"></a>00313           unFilterScanline(&amp;out_[linestart - y], &amp;scanlines[linestart + 1], prevline, bytewidth, filterType,  linelength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00314"></a>00314           linestart += (1 + linelength); <span class="comment">//go to start of next scanline</span>
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316         <span class="keywordflow">else</span> <span class="comment">//less than 8 bits per pixel, so fill it up bit per bit</span>
<a name="l00317"></a>00317         {
<a name="l00318"></a>00318           std::vector&lt;unsigned char&gt; templine((info.width * bpp + 7) &gt;&gt; 3); <span class="comment">//only used if bpp &lt; 8</span>
<a name="l00319"></a>00319           <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> y = 0, obp = 0; y &lt; info.height; y++)
<a name="l00320"></a>00320           {
<a name="l00321"></a>00321             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType = scanlines[linestart];
<a name="l00322"></a>00322             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* prevline = (y == 0) ? 0 : &amp;out_[(y - 1) * info.width * bytewidth];
<a name="l00323"></a>00323             unFilterScanline(&amp;templine[0], &amp;scanlines[linestart + 1], prevline, bytewidth, filterType, linelength); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00324"></a>00324             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> bp = 0; bp &lt; info.width * bpp;) setBitOfReversedStream(obp, out_, readBitFromReversedStream(bp, &amp;templine[0]));
<a name="l00325"></a>00325             linestart += (1 + linelength); <span class="comment">//go to start of next scanline</span>
<a name="l00326"></a>00326           }
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328       }
<a name="l00329"></a>00329       <span class="keywordflow">else</span> <span class="comment">//interlaceMethod is 1 (Adam7)</span>
<a name="l00330"></a>00330       {
<a name="l00331"></a>00331         <span class="keywordtype">size_t</span> passw[7] = { (info.width + 7) / 8, (info.width + 3) / 8, (info.width + 3) / 4, (info.width + 1) / 4, (info.width + 1) / 2, (info.width + 0) / 2, (info.width + 0) / 1 };
<a name="l00332"></a>00332         <span class="keywordtype">size_t</span> passh[7] = { (info.height + 7) / 8, (info.height + 7) / 8, (info.height + 3) / 8, (info.height + 3) / 4, (info.height + 1) / 4, (info.height + 1) / 2, (info.height + 0) / 2 };
<a name="l00333"></a>00333         <span class="keywordtype">size_t</span> passstart[7] = {0};
<a name="l00334"></a>00334         <span class="keywordtype">size_t</span> pattern[28] = {0,4,0,2,0,1,0,0,0,4,0,2,0,1,8,8,4,4,2,2,1,8,8,8,4,4,2,2}; <span class="comment">//values for the adam7 passes</span>
<a name="l00335"></a>00335         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 6; i++) passstart[i + 1] = passstart[i] + passh[i] * ((passw[i] ? 1 : 0) + (passw[i] * bpp + 7) / 8);
<a name="l00336"></a>00336         std::vector&lt;unsigned char&gt; scanlineo((info.width * bpp + 7) / 8), scanlinen((info.width * bpp + 7) / 8); <span class="comment">//&quot;old&quot; and &quot;new&quot; scanline</span>
<a name="l00337"></a>00337         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++)
<a name="l00338"></a>00338           adam7Pass(&amp;out_[0], &amp;scanlinen[0], &amp;scanlineo[0], &amp;scanlines[passstart[i]], info.width, pattern[i], pattern[i + 7], pattern[i + 14], pattern[i + 21], passw[i], passh[i], bpp);
<a name="l00339"></a>00339       }
<a name="l00340"></a>00340       <span class="keywordflow">if</span>(info.colorType != 6 || info.bitDepth != 8) <span class="comment">//conversion needed</span>
<a name="l00341"></a>00341       {
<a name="l00342"></a>00342         std::vector&lt;unsigned char&gt; data = out;
<a name="l00343"></a>00343         error = convert(out, &amp;data[0], info, info.width, info.height);
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346     <span class="keywordtype">void</span> readPngHeader(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> inlength) <span class="comment">//read the information from the header and store it in the Info</span>
<a name="l00347"></a>00347     {
<a name="l00348"></a>00348       <span class="keywordflow">if</span>(inlength &lt; 29) { error = 27; <span class="keywordflow">return</span>; } <span class="comment">//error: the data length is smaller than the length of the header</span>
<a name="l00349"></a>00349       <span class="keywordflow">if</span>(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) { error = 28; <span class="keywordflow">return</span>; } <span class="comment">//no PNG signature</span>
<a name="l00350"></a>00350       <span class="keywordflow">if</span>(in[12] != <span class="charliteral">&#39;I&#39;</span> || in[13] != <span class="charliteral">&#39;H&#39;</span> || in[14] != <span class="charliteral">&#39;D&#39;</span> || in[15] != <span class="charliteral">&#39;R&#39;</span>) { error = 29; <span class="keywordflow">return</span>; } <span class="comment">//error: it doesn&#39;t start with a IHDR chunk!</span>
<a name="l00351"></a>00351       info.width = read32bitInt(&amp;in[16]); info.height = read32bitInt(&amp;in[20]);
<a name="l00352"></a>00352       info.bitDepth = in[24]; info.colorType = in[25];
<a name="l00353"></a>00353       info.compressionMethod = in[26]; <span class="keywordflow">if</span>(in[26] != 0) { error = 32; <span class="keywordflow">return</span>; } <span class="comment">//error: only compression method 0 is allowed in the specification</span>
<a name="l00354"></a>00354       info.filterMethod = in[27]; <span class="keywordflow">if</span>(in[27] != 0) { error = 33; <span class="keywordflow">return</span>; } <span class="comment">//error: only filter method 0 is allowed in the specification</span>
<a name="l00355"></a>00355       info.interlaceMethod = in[28]; <span class="keywordflow">if</span>(in[28] &gt; 1) { error = 34; <span class="keywordflow">return</span>; } <span class="comment">//error: only interlace methods 0 and 1 exist in the specification</span>
<a name="l00356"></a>00356       error = checkColorValidity(info.colorType, info.bitDepth);
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358     <span class="keywordtype">void</span> unFilterScanline(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* recon, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* scanline, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* precon, <span class="keywordtype">size_t</span> bytewidth, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> filterType, <span class="keywordtype">size_t</span> length)
<a name="l00359"></a>00359     {
<a name="l00360"></a>00360       <span class="keywordflow">switch</span>(filterType)
<a name="l00361"></a>00361       {
<a name="l00362"></a>00362         <span class="keywordflow">case</span> 0: <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; length; i++) recon[i] = scanline[i]; <span class="keywordflow">break</span>;
<a name="l00363"></a>00363         <span class="keywordflow">case</span> 1:
<a name="l00364"></a>00364           <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i =         0; i &lt; bytewidth; i++) recon[i] = scanline[i];
<a name="l00365"></a>00365           <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = bytewidth; i &lt;    length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
<a name="l00366"></a>00366           <span class="keywordflow">break</span>;
<a name="l00367"></a>00367         <span class="keywordflow">case</span> 2:
<a name="l00368"></a>00368           <span class="keywordflow">if</span>(precon) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; length; i++) recon[i] = scanline[i] + precon[i];
<a name="l00369"></a>00369           <span class="keywordflow">else</span>       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; length; i++) recon[i] = scanline[i];
<a name="l00370"></a>00370           <span class="keywordflow">break</span>;
<a name="l00371"></a>00371         <span class="keywordflow">case</span> 3:
<a name="l00372"></a>00372           <span class="keywordflow">if</span>(precon)
<a name="l00373"></a>00373           {
<a name="l00374"></a>00374             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i =         0; i &lt; bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
<a name="l00375"></a>00375             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = bytewidth; i &lt;    length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
<a name="l00376"></a>00376           }
<a name="l00377"></a>00377           <span class="keywordflow">else</span>
<a name="l00378"></a>00378           {
<a name="l00379"></a>00379             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i =         0; i &lt; bytewidth; i++) recon[i] = scanline[i];
<a name="l00380"></a>00380             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = bytewidth; i &lt;    length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
<a name="l00381"></a>00381           }
<a name="l00382"></a>00382           <span class="keywordflow">break</span>;
<a name="l00383"></a>00383         <span class="keywordflow">case</span> 4:
<a name="l00384"></a>00384           <span class="keywordflow">if</span>(precon)
<a name="l00385"></a>00385           {
<a name="l00386"></a>00386             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i =         0; i &lt; bytewidth; i++) recon[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(scanline[i] + paethPredictor(0, precon[i], 0));
<a name="l00387"></a>00387             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = bytewidth; i &lt;    length; i++) recon[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
<a name="l00388"></a>00388           }
<a name="l00389"></a>00389           <span class="keywordflow">else</span>
<a name="l00390"></a>00390           {
<a name="l00391"></a>00391             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i =         0; i &lt; bytewidth; i++) recon[i] = scanline[i];
<a name="l00392"></a>00392             <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = bytewidth; i &lt;    length; i++) recon[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0));
<a name="l00393"></a>00393           }
<a name="l00394"></a>00394           <span class="keywordflow">break</span>;
<a name="l00395"></a>00395         <span class="keywordflow">default</span>: error = 36; <span class="keywordflow">return</span>; <span class="comment">//error: unexisting filter type given</span>
<a name="l00396"></a>00396       }
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398     <span class="keywordtype">void</span> adam7Pass(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* linen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* lineo, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> w, <span class="keywordtype">size_t</span> passleft, <span class="keywordtype">size_t</span> passtop, <span class="keywordtype">size_t</span> spacex, <span class="keywordtype">size_t</span> spacey, <span class="keywordtype">size_t</span> passw, <span class="keywordtype">size_t</span> passh, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bpp)
<a name="l00399"></a>00399     { <span class="comment">//filter and reposition the pixels into the output when the image is Adam7 interlaced. This function can only do it after the full image is already decoded. The out buffer must have the correct allocated memory size already.</span>
<a name="l00400"></a>00400       <span class="keywordflow">if</span>(passw == 0) <span class="keywordflow">return</span>;
<a name="l00401"></a>00401       <span class="keywordtype">size_t</span> bytewidth = (bpp + 7) / 8, linelength = 1 + ((bpp * passw + 7) / 8);
<a name="l00402"></a>00402       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> y = 0; y &lt; passh; y++)
<a name="l00403"></a>00403       {
<a name="l00404"></a>00404         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> filterType = in[y * linelength], *prevline = (y == 0) ? 0 : lineo;
<a name="l00405"></a>00405         unFilterScanline(linen, &amp;in[y * linelength + 1], prevline, bytewidth, filterType, (w * bpp + 7) / 8); <span class="keywordflow">if</span>(error) <span class="keywordflow">return</span>;
<a name="l00406"></a>00406         <span class="keywordflow">if</span>(bpp &gt;= 8) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; passw; i++) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> b = 0; b &lt; bytewidth; b++) <span class="comment">//b = current byte of this pixel</span>
<a name="l00407"></a>00407           out[bytewidth * w * (passtop + spacey * y) + bytewidth * (passleft + spacex * i) + b] = linen[bytewidth * i + b];
<a name="l00408"></a>00408         <span class="keywordflow">else</span> <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; passw; i++)
<a name="l00409"></a>00409         {
<a name="l00410"></a>00410           <span class="keywordtype">size_t</span> obp = bpp * w * (passtop + spacey * y) + bpp * (passleft + spacex * i), bp = i * bpp;
<a name="l00411"></a>00411           <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> b = 0; b &lt; bpp; b++) setBitOfReversedStream(obp, out, readBitFromReversedStream(bp, &amp;linen[0]));
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* temp = linen; linen = lineo; lineo = temp; <span class="comment">//swap the two buffer pointers &quot;line old&quot; and &quot;line new&quot;</span>
<a name="l00414"></a>00414       }
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitFromReversedStream(<span class="keywordtype">size_t</span>&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits) { <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = (bits[bitp &gt;&gt; 3] &gt;&gt; (7 - (bitp &amp; 0x7))) &amp; 1; bitp++; <span class="keywordflow">return</span> result;}
<a name="l00417"></a>00417     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> readBitsFromReversedStream(<span class="keywordtype">size_t</span>&amp; bitp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbits)
<a name="l00418"></a>00418     {
<a name="l00419"></a>00419       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> result = 0;
<a name="l00420"></a>00420       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = nbits - 1; i &lt; nbits; i--) result += ((readBitFromReversedStream(bitp, bits)) &lt;&lt; i);
<a name="l00421"></a>00421       <span class="keywordflow">return</span> result;
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423     <span class="keywordtype">void</span> setBitOfReversedStream(<span class="keywordtype">size_t</span>&amp; bitp, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bits, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bit) { bits[bitp &gt;&gt; 3] |=  (bit &lt;&lt; (7 - (bitp &amp; 0x7))); bitp++; }
<a name="l00424"></a>00424     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> read32bitInt(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer) { <span class="keywordflow">return</span> (buffer[0] &lt;&lt; 24) | (buffer[1] &lt;&lt; 16) | (buffer[2] &lt;&lt; 8) | buffer[3]; }
<a name="l00425"></a>00425     <span class="keywordtype">int</span> checkColorValidity(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> colorType, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bd) <span class="comment">//return type is a LodePNG error code</span>
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       <span class="keywordflow">if</span>((colorType == 2 || colorType == 4 || colorType == 6)) { <span class="keywordflow">if</span>(!(bd == 8 || bd == 16)) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; }
<a name="l00428"></a>00428       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(colorType == 0) { <span class="keywordflow">if</span>(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; }
<a name="l00429"></a>00429       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(colorType == 3) { <span class="keywordflow">if</span>(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) <span class="keywordflow">return</span> 37; <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; }
<a name="l00430"></a>00430       <span class="keywordflow">else</span> <span class="keywordflow">return</span> 31; <span class="comment">//unexisting color type</span>
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> getBpp(<span class="keyword">const</span> Info&amp; info)
<a name="l00433"></a>00433     {
<a name="l00434"></a>00434       <span class="keywordflow">if</span>(info.colorType == 2) <span class="keywordflow">return</span> (3 * info.bitDepth);
<a name="l00435"></a>00435       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(info.colorType &gt;= 4) <span class="keywordflow">return</span> (info.colorType - 2) * info.bitDepth;
<a name="l00436"></a>00436       <span class="keywordflow">else</span> <span class="keywordflow">return</span> info.bitDepth;
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438     <span class="keywordtype">int</span> convert(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, Info&amp; infoIn, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> w, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> h)
<a name="l00439"></a>00439     { <span class="comment">//converts from any color type to 32-bit. return value = LodePNG error code</span>
<a name="l00440"></a>00440       <span class="keywordtype">size_t</span> numpixels = w * h, bp = 0;
<a name="l00441"></a>00441       out.resize(numpixels * 4);
<a name="l00442"></a>00442       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out_ = out.empty() ? 0 : &amp;out[0]; <span class="comment">//faster if compiled without optimization</span>
<a name="l00443"></a>00443       <span class="keywordflow">if</span>(infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span>
<a name="l00444"></a>00444       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00445"></a>00445       {
<a name="l00446"></a>00446         out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[i];
<a name="l00447"></a>00447         out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; in[i] == infoIn.key_r) ? 0 : 255;
<a name="l00448"></a>00448       }
<a name="l00449"></a>00449       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 2) <span class="comment">//RGB color</span>
<a name="l00450"></a>00450       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00451"></a>00451       {
<a name="l00452"></a>00452         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 3; c++) out_[4 * i + c] = in[3 * i + c];
<a name="l00453"></a>00453         out_[4 * i + 3] = (infoIn.key_defined == 1 &amp;&amp; in[3 * i + 0] == infoIn.key_r &amp;&amp; in[3 * i + 1] == infoIn.key_g &amp;&amp; in[3 * i + 2] == infoIn.key_b) ? 0 : 255;
<a name="l00454"></a>00454       }
<a name="l00455"></a>00455       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 3) <span class="comment">//indexed color (palette)</span>
<a name="l00456"></a>00456       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00457"></a>00457       {
<a name="l00458"></a>00458         <span class="keywordflow">if</span>(4U * in[i] &gt;= infoIn.palette.size()) <span class="keywordflow">return</span> 46;
<a name="l00459"></a>00459         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 4; c++) out_[4 * i + c] = infoIn.palette[4 * in[i] + c]; <span class="comment">//get rgb colors from the palette</span>
<a name="l00460"></a>00460       }
<a name="l00461"></a>00461       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 4) <span class="comment">//greyscale with alpha</span>
<a name="l00462"></a>00462       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00463"></a>00463       {
<a name="l00464"></a>00464         out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i + 0];
<a name="l00465"></a>00465         out_[4 * i + 3] = in[2 * i + 1];
<a name="l00466"></a>00466       }
<a name="l00467"></a>00467       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 8 &amp;&amp; infoIn.colorType == 6) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 4; c++) out_[4 * i + c] = in[4 * i + c]; <span class="comment">//RGB with alpha</span>
<a name="l00468"></a>00468       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span>
<a name="l00469"></a>00469       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00470"></a>00470       {
<a name="l00471"></a>00471         out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i];
<a name="l00472"></a>00472         out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; 256U * in[i] + in[i + 1] == infoIn.key_r) ? 0 : 255;
<a name="l00473"></a>00473       }
<a name="l00474"></a>00474       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 2) <span class="comment">//RGB color</span>
<a name="l00475"></a>00475       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00476"></a>00476       {
<a name="l00477"></a>00477         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 3; c++) out_[4 * i + c] = in[6 * i + 2 * c];
<a name="l00478"></a>00478         out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; 256U*in[6*i+0]+in[6*i+1] == infoIn.key_r &amp;&amp; 256U*in[6*i+2]+in[6*i+3] == infoIn.key_g &amp;&amp; 256U*in[6*i+4]+in[6*i+5] == infoIn.key_b) ? 0 : 255;
<a name="l00479"></a>00479       }
<a name="l00480"></a>00480       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 4) <span class="comment">//greyscale with alpha</span>
<a name="l00481"></a>00481       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00482"></a>00482       {
<a name="l00483"></a>00483         out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[4 * i]; <span class="comment">//most significant byte</span>
<a name="l00484"></a>00484         out_[4 * i + 3] = in[4 * i + 2];
<a name="l00485"></a>00485       }
<a name="l00486"></a>00486       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth == 16 &amp;&amp; infoIn.colorType == 6) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++) <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 4; c++) out_[4 * i + c] = in[8 * i + 2 * c]; <span class="comment">//RGB with alpha</span>
<a name="l00487"></a>00487       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth &lt; 8 &amp;&amp; infoIn.colorType == 0) <span class="comment">//greyscale</span>
<a name="l00488"></a>00488       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00489"></a>00489       {
<a name="l00490"></a>00490         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value = (readBitsFromReversedStream(bp, in, infoIn.bitDepth) * 255) / ((1 &lt;&lt; infoIn.bitDepth) - 1); <span class="comment">//scale value from 0 to 255</span>
<a name="l00491"></a>00491         out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = (<span class="keywordtype">unsigned</span> char)(value);
<a name="l00492"></a>00492         out_[4 * i + 3] = (infoIn.key_defined &amp;&amp; value &amp;&amp; ((1U &lt;&lt; infoIn.bitDepth) - 1U) == infoIn.key_r &amp;&amp; ((1U &lt;&lt; infoIn.bitDepth) - 1U)) ? 0 : 255;
<a name="l00493"></a>00493       }
<a name="l00494"></a>00494       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(infoIn.bitDepth &lt; 8 &amp;&amp; infoIn.colorType == 3) <span class="comment">//palette</span>
<a name="l00495"></a>00495       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; numpixels; i++)
<a name="l00496"></a>00496       {
<a name="l00497"></a>00497         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value = readBitsFromReversedStream(bp, in, infoIn.bitDepth);
<a name="l00498"></a>00498         <span class="keywordflow">if</span>(4 * value &gt;= infoIn.palette.size()) <span class="keywordflow">return</span> 47;
<a name="l00499"></a>00499         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> c = 0; c &lt; 4; c++) out_[4 * i + c] = infoIn.palette[4 * value + c]; <span class="comment">//get rgb colors from the palette</span>
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       <span class="keywordflow">return</span> 0;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503     <span class="keywordtype">long</span> paethPredictor(<span class="keywordtype">long</span> a, <span class="keywordtype">long</span> b, <span class="keywordtype">long</span> c) <span class="comment">//Paeth predicter, used by PNG filter type 4</span>
<a name="l00504"></a>00504     {
<a name="l00505"></a>00505       <span class="keywordtype">long</span> p = a + b - c, pa = p &gt; a ? (p - a) : (a - p), pb = p &gt; b ? (p - b) : (b - p), pc = p &gt; c ? (p - c) : (c - p);
<a name="l00506"></a>00506       <span class="keywordflow">return</span> (pa &lt;= pb &amp;&amp; pa &lt;= pc) ? a : pb &lt;= pc ? b : c;
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508   };
<a name="l00509"></a>00509   PNG decoder; decoder.decode(out_image_32bit, in_png, in_size);
<a name="l00510"></a>00510   image_width = decoder.info.width; image_height = decoder.info.height;
<a name="l00511"></a>00511   <span class="keywordflow">return</span> decoder.error;
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 } <span class="comment">// namespace png</span>
<a name="l00515"></a>00515 } <span class="comment">// namespace x2d</span>
<a name="l00516"></a>00516 <span class="keyword">using namespace </span>x2d::png;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="preprocessor">#endif // __X2D_PICOPNG_H__</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
